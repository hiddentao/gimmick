"use strict";



var _ = require('lodash'),
  debug = require('debug')('tracejs-instrumenter'),
  esprima = require('esprima');



var Instrumenter = exports.Instrumenter = function() {
  this._definitions = [];
  this._stack = [];
};


/**
 * Process given AST node.
 *
 * This can be called more than once with different ASTs.
 *
 * @param {String} filename Name of file from which AST was generated.
 * @param  {Object} ast An AST generated by `esprima`.
 */
Instrumenter.prototype.process = function(filename, ast) {
  this._stack = [];
  this._filename = filename;
  this._process(ast);
};




/** 
 * Get id definitions.
 * 
 * @return {Object}
 */
Instrumenter.prototype.getDefinitions = function() {
  return this._definitions;
};





Instrumenter.prototype._process = function(node, meta) {
  if (!node) return;

  if (node.type) {
    debug('process ' + node.type);

    var fn = this['_process' + node.type];

    if (fn) {
      fn.call(this, node, meta || {});
    }
  }
};


Instrumenter.prototype._processChildren = function(node) {
  var key;

  for (key in node) {
    this._process(node[key]);
  };
};


Instrumenter.prototype._processProgram = function(node) {
  this._processChildren(node.body);
};


Instrumenter.prototype._processExpressionStatement = function(node) {
  this._process(node.expression);
};



Instrumenter.prototype._processAssignmentExpression = function(node) {
  this._process(node.right);
};



Instrumenter.prototype._processCallExpression = function(node) {
  this._process(node.callee);
};


Instrumenter.prototype._processVariableDeclaration = function(node) {
  this._processChildren(node.declarations);
};


Instrumenter.prototype._processReturnStatement = function(node) {
  this._process(node.argument);
};


Instrumenter.prototype._processVariableDeclarator = function(node) {
  this._process(node.init);
};


Instrumenter.prototype._processSwitchStatement = function(node) {
  this._process(node.discriminant);
  this._processChildren(node.cases);
};


Instrumenter.prototype._processSwitchCase = function(node) {
  this._process(node.consequent);
};


Instrumenter.prototype._processIfStatement = function(node) {
  this._process(node.test);
  this._process(node.consequent);
  this._process(node.alternate);
};


Instrumenter.prototype._processLogicalExpression = function(node) {
  this._process(node.left);
  this._process(node.right);
};



Instrumenter.prototype._processBinaryExpression = function(node) {
  this._process(node.left);
  this._process(node.right);
};



Instrumenter.prototype._processWithStatement = function(node) {
  this._processChildren(node.object);
  this._processChildren(node.body);
};


Instrumenter.prototype._processFunctionDeclaration = function(node) {
  this._processFunctionExpression(node);
};


Instrumenter.prototype._processFunctionExpression = function(node) {
  var currentFn = {
    file: this._filename,
    name: (node.id && node.id.Identifier && node.id.Identifier.name ? node.id.Identifier.name : 'anon'),
    loc: _.cloneDeep(node.loc),
  };

  this._definitions.push(currentFn);
  currentFn.id = this._definitions.length - 1;

  // push onto stack
  this._stack.push(currentFn);

  // process body
  this._process(node.body, {
    context: 'function'
  });

  // pop from stack
  if (this._stack.length 
      && currentFn === this._stack[this._stack.length - 1]) {
    this._stack.pop();
  }
};



Instrumenter.prototype._processBlockStatement = function(node, meta) {
  var block = this._stack.length
    ? this._stack[this._stack.length - 1]
    : null;

  /*
   TODO: 

   If we see a `return` statement then split it up. Do a `var` assignment, 
   then an 'exit log' then the `return` statement.
   */


  // for each child
  for (var idx=0; node.body.length>idx; ++idx) {
    var childNode = node.body[idx];

    this._process(childNode);

    // if child is a 'return statement' then log 'exit' just before it
    if (block && 'ReturnStatement' === childNode.type) {
      node.body.splice(idx, 0, esprima.parse('_tjs(' + block.id + ', 2, Date.now());'));
      idx++;
    }
  }

  // if it's a function block
  if (block && meta.context && 'function' === meta.context) {
    // entry
    node.body.unshift(esprima.parse('_tjs(' + block.id + ', 1, Date.now());'));
    // exit
    node.body.push(esprima.parse('_tjs(' + block.id + ', 2, Date.now());'));
  }
};


