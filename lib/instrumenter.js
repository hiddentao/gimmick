"use strict";



var _ = require('lodash'),
  debug = require('debug')('gimmick-instrumenter'),
  escodegen = require('escodegen'),
  esprima = require('esprima');



var Instrumenter = exports.Instrumenter = function() {
  this._retVarCounter = 0;
  this._definitions = [];
  this._stack = [];
};


/**
 * Process given AST node.
 *
 * This can be called more than once with different ASTs.
 *
 * @param {String} filename Name of file from which AST was generated.
 * @param  {Object} ast An AST generated by `esprima`.
 */
Instrumenter.prototype.process = function(filename, ast) {
  this._stack = [];
  this._filename = filename;
  this._process(ast);
};




/** 
 * Get id definitions.
 * 
 * @return {Object}
 */
Instrumenter.prototype.getDefinitions = function() {
  return this._definitions;
};





Instrumenter.prototype._process = function(node, meta) {
  if (!node) return;

  if (node.type) {
    debug('process ' + node.type);

    var fn = this['_process' + node.type];

    if (fn) {
      fn.call(this, node, meta || {});
    }
  }
};


Instrumenter.prototype._processChildren = function(node) {
  var key;

  for (key in node) {
    this._process(node[key]);
  };
};


Instrumenter.prototype._processProgram = function(node) {
  this._processChildren(node.body);
};


Instrumenter.prototype._processExpressionStatement = function(node) {
  this._process(node.expression);
};



Instrumenter.prototype._processAssignmentExpression = function(node) {
  this._process(node.right);
};



Instrumenter.prototype._processCallExpression = function(node) {
  this._process(node.callee);
  this._processChildren(node.arguments);
};


Instrumenter.prototype._processVariableDeclaration = function(node) {
  this._processChildren(node.declarations);
};


Instrumenter.prototype._processReturnStatement = function(node) {
  this._process(node.argument);
};


Instrumenter.prototype._processVariableDeclarator = function(node) {
  this._process(node.init);
};


Instrumenter.prototype._processSwitchStatement = function(node) {
  this._process(node.discriminant);
  this._processChildren(node.cases);
};


Instrumenter.prototype._processSwitchCase = function(node) {
  this._process(node.consequent);
};


Instrumenter.prototype._processIfStatement = function(node) {
  this._process(node.test);
  this._process(node.consequent);
  this._process(node.alternate);
};


Instrumenter.prototype._processLogicalExpression = function(node) {
  this._process(node.left);
  this._process(node.right);
};



Instrumenter.prototype._processBinaryExpression = function(node) {
  this._process(node.left);
  this._process(node.right);
};



Instrumenter.prototype._processWithStatement = function(node) {
  this._processChildren(node.object);
  this._processChildren(node.body);
};


Instrumenter.prototype._processFunctionDeclaration = function(node) {
  this._processFunctionExpression(node);
};


Instrumenter.prototype._processFunctionExpression = function(node) {
  var currentFn = {
    file: this._filename,
    name: (node.id && node.id.name ? node.id.name : 'anon'),
    loc: _.cloneDeep(node.loc),
  };

  this._definitions.push(currentFn);
  currentFn.id = this._definitions.length - 1;

  // push onto stack
  this._stack.push(currentFn);

  // process body
  this._process(node.body, {
    context: 'function'
  });

  // pop from stack
  if (this._stack.length 
      && currentFn === this._stack[this._stack.length - 1]) {
    this._stack.pop();
  }
};



Instrumenter.prototype._processBlockStatement = function(node, meta) {
  var block = this._stack.length
    ? this._stack[this._stack.length - 1]
    : null;

  // for each child
  for (var idx=0; node.body.length>idx; ++idx) {
    var childNode = node.body[idx];

    this._process(childNode);

    // if child is a 'return statement' then log 'exit' just before it
    if (block && 'ReturnStatement' === childNode.type) {
      var replacements = [];

      // add:  var __retxx = ...
      var retVarName = '__ret' + (++this._retVarCounter);
      replacements.push(
        esprima.parse('var ' + retVarName + ' = ' + escodegen.generate(childNode.argument) + ';')
      );

      // add exit log
      replacements.push(
        this._createLogNode(block.id, 2)
      );

      // add return __retxx
      replacements.push({
        type: 'ReturnStatement',
        argument: {
          type: 'Identifier',
          name: retVarName
        }
      });
      
      // replace
      node.body.splice.apply(node.body, [idx, 3].concat(replacements));

      // skip newly added nodes
      idx+=2;
    }
  }

  // if it's a function block
  if (block && meta.context && 'function' === meta.context) {
    // entry
    node.body.unshift(
      this._createLogNode(block.id, 1)
    );
    // exit
    if (node.body.length && 'ReturnStatement' !== node.body[node.body.length-1].type) {
      node.body.push(
        this._createLogNode(block.id, 2)
      );      
    }
  }
};




Instrumenter.prototype._createLogNode = function(id, mode) {
  return esprima.parse('__gmk(' + id + ',' + mode + ');');
};





